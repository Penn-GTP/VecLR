## Break down alignment in a set of bam files generated by aligning the same long read library to multiple references
fyml <- 'C790_22-176_LE_D354.yaml';
BreakdownAlnWrapper <- function(yml=NA, fyml=NA) {
  
  require(yaml);
  require(Biostrings);
  require(Rsamtools);
  require(ShortRead);
  
  ########################
  ## Internal functions ##
  ########################
  #############################################
  ## Match sequence names, such as 'chr1' and '1'
  get_matching_seqname <- function(seqn1, seqn0) {
    olp <- intersect(seqn1, seqn0); 
    if (length(olp) > 0) seqn1 else { # do nothing if there is any common names
      olp <- intersect(sub('chr', '', seqn1, ignore.case = TRUE), sub('chr', '', seqn0, ignore.case = TRUE));
      if (length(olp) == 0) seqn1 else { # do nothing if no common names anyway
        seqn2 <- sub('chr', '', seqn1, ignore.case = TRUE);
        seqn3 <- paste0('chr', seqn1);
        seqn4 <- paste0('CHR', seqn1);
        
        olp2 <- intersect(seqn2, seqn0);
        olp3 <- intersect(seqn3, seqn0);
        olp4 <- intersect(seqn4, seqn0);
        
        if (length(olp2) > 0) seqn2 else if (length(olp3) > 0) seqn3 else if (length(olp4) > 0) seqn4 else seqn1;
      }
    }
  }
  
  #############################################
  ## Prepare a list of genome regions to load a subset of alignment in the bam file
  get_loading_range <- function(roi, fbam) {
    if (is.null(roi)) roi <- "";
    froi <- roi[file.exists(roi)];
    if (length(froi) > 0) { # ROI is given as a bed file
      lns <- readLines(froi);
      lns <- lns[!grepl('^#', lns)];
      rng <- strsplit(lns, '\t');
    } else if (is.character(roi)) {  # ROI is given as a string
      rng <- strsplit(roi, '[,;]')[[1]];
      rng <- strsplit(rng, '[:_\\-]');
    } else rng <- list(c('', '', '')); # ROI is not given
    
    rng <- data.frame(name=sapply(rng, function(x) x[1]), start=as.integer(sapply(rng, function(x) x[2])), end=as.integer(sapply(rng, function(x) x[3])));
    rng <- rng[!is.na(rng$start) & !is.na(rng$end), , drop=FALSE];
    
    ## Match sequence names
    seqn <- names(scanBamHeader(fbam)[[1]][[1]]);
    rng[, 1] <- get_matching_seqname(rng[, 1], seqn);
    
    if (nrow(rng) == 0) IRangesList() else as(GRanges(rng[, 1], IRanges(rng[, 2], rng[, 3])), 'IRangesList');
  }
  
  #############################################
  ## Prepare annotated regions
  get_anno_range <- function(ann, fbam, fill.gap=TRUE) {
    ## seq info in bam file
    bseq <- scanBamHeader(fbam[1])[[1]][[1]];
    
    ## parse regions
    if (is.null(ann)) ann <- "";
    fann <- ann[file.exists(ann)];
    if (length(fann) == 0) {
      rng <- data.frame(seqname=character(), name=character(), start=integer(), end=integer(), stringsAsFactors = FALSE);
    } else { # ROI is given as a bed file
      lns <- readLines(fann);
      lns <- lns[!grepl('^#', lns)];
      rng <- strsplit(lns, '\t');
      rng <- data.frame(seqname=sapply(rng, function(x) x[1]), name=sapply(rng, function(x) x[4]),
                        start=as.integer(sapply(rng, function(x) x[2])), end=as.integer(sapply(rng, function(x) x[3])));
      rng <- rng[!is.na(rng$start) & !is.na(rng$end), , drop=FALSE];
      rng[, 1] <- get_matching_seqname(rng[, 1], names(bseq));
      rng <- rng[rng[, 1] %in% names(bseq), , drop=FALSE];
    } 
    
    ## create GRanges object
    if (nrow(rng) == 0) { # use seq info in bam file
      gr <- GRanges(names(bseq), IRanges(1, bseq), seqlengths = bseq);
      names(gr) <- names(bseq);
    } else { # use provided bed file
      gr <- GRanges(rng$seqname, IRanges(rng$start, rng$end), seqlengths = bseq[unique(rng$seqname)]);
      names(gr) <- rng$name;
    }
    
    ## Fill in unannotated regions
    lst <- lapply(seqlevels(gr), function(snm) {
      g <- gr[seqnames(gr)==snm];
      
      ## Fill un-annotated gaps
      if (fill.gap) {
        l <- seqlengths(gr)[snm];
        c <- coverage(g, width = l);
        x <- as(c, 'GRanges');
        x <- x[x$score==0];
        if (length(x) == 0) g else {
          x <- GRanges(snm, IRanges(start(x), end(x)));
          names(x) <- sapply(1:length(x), function(i) {
            if (end(x)[i] < min(start(g))) 'upstream' else if (start(x)[i] > max(end(g))) 'downstream' else {
              g1 <- g[end(g)<start(x)[i]];
              g2 <- g[start(g)>end(x)[i]];
              paste0(names(g1)[end(g1)==max(end(g1))], '--', names(g2)[start(g2)==min(start(g2))]);
            }
          });
          names(x) <- paste0('un-anno--', names(x));
        };
        g <- c(g, x);
      }
      
      g <- g[order(end(g))];
      g <- g[order(start(g))];
      g@ranges;
    });
    names(lst) <- seqlevels(gr);
    
    lst;
  }
  
  #############################################
  ## load alignment from a bam using given parameters
  load_align_table <- function(fbam, flag, what, which) {
    aln <- data.frame(scanBam(fbam[1], param = ScanBamParam(flag=flag, what=what, which=which))[[1]], stringsAsFactors = FALSE);
    aln;
  }
  #############################################
  
  ######################################################
  fyml <- fyml[file.exists(fyml)];
  if (length(fyml) > 0) yml <- yaml.load_file(fyml[1]);
  ######################################################
  
  ######################################################
  ## Load and break down alignment to host genomes
  gyml <- yml$input$genome;
  
  ## Check availability of bam files and reference BSgenome object
  gflg <- sapply(gyml, function(prm) {
    # Whether a bam file is given
    if (!file.exists(prm$bam[1])) flg1 <- FALSE else flg1 <- identical('BAM', substr(readLines(prm$bam[1], n=1 , warn = FALSE), 1, 3));
    
    # Whether a BSgenome package of the reference genome is installed
    flg2 <- require(prm$ref[1], character.only = TRUE, quietly = TRUE);
    
    flg1 & flg2;
  });
  gyml <- gyml[gflg];
  
  ######################################################
  ## Break down alignments to genomes
  if (length(gyml) == 0) gbrk <- NULL else {
    gbrk <- lapply(gyml, function(prm) {
      # Index bam file if not done yet
      fbam <- prm$bam[1];
      if (length(BamFile(fbam)$index) == 0) indexBam(fbam);
      
      # Prepare ScanBamParam
      flg <- scanBamFlag(isUnmappedQuery = FALSE);
      wht <- c("qname", "flag", "rname", "strand", "pos", "qwidth", "mapq", "cigar", "seq");
      whh <- get_loading_range(prm$roi, fbam);
      
      # Prepare reference sequence
      require(prm$ref, character.only = TRUE);
      gname <- sub('\\..+$', '', sub('^BSgenome.', '', prm$ref));
      assign("gref", get(prm$ref));
      seqnames(gref) <- get_matching_seqname(names(gref), names(scanBamHeader(fbam[1])[[1]][[1]]));
      
      # Prepare region annotation 
      gann <- get_anno_range(prm$ann, fbam);
      
      #################################################
      galn <- load_align_table(fbam, flg, wht, whh); ##
      #################################################
      
      galn$rname <- as.character(galn$rname);
      galn <- galn[galn$rname %in% names(gref) & galn$rname %in% names(gann), , drop=FALSE];
      
      ##################################################################################
      ## Break down alignment one by one
      if (nrow(galn) == 0) gsmm <- NULL else { 
        gsmm <- lapply(1:nrow(galn), function(i) { # print(i);
          bas <- BreakdownAlnByBase(galn, i, gref[[galn$rname[i]]]);
          smm <- BreakdownAlnByRegion(bas, gann[[galn$rname[[i]]]]);
          smm <- 
          cbind(seq_name=galn$rname[i], read_id=galn$qname[i], smm); 
        });
        names(gsmm) <- rownames(galn);
      }
      ##################################################################################
      
      gsmm;
    }); 
  };
  ######################################################  
  
  ######################################################
  ## Load and break down alignment to vectors
  vyml <- yml$input$vector;
  ######################################################
  
  ## Check availability of bam files and reference BSgenome object
  vflg <- sapply(vyml, function(prm) {
    # Whether a bam file is given
    if (!file.exists(prm$bam[1])) flg1 <- FALSE else flg1 <- identical('BAM', substr(readLines(prm$bam[1], n=1 , warn = FALSE), 1, 3));
    
    # Whether a fasta of the reference sequence exists
    flg2 <- file.exists(prm$ref[1]);
    
    flg1 & flg2;
  });
  vyml <- vyml[vflg];
  
  ######################################################
  ## Break down alignments to genomes
  if (length(vyml) == 0) vbrk <- NULL else {
    vbrk <- lapply(vyml, function(prm) { 
      # Index bam file if not done yet
      fbam <- prm$bam[1];
      if (length(BamFile(fbam)$index) == 0) indexBam(fbam);
      
      # Prepare ScanBamParam
      flg <- scanBamFlag(isUnmappedQuery = FALSE);
      wht <- c("qname", "flag", "rname", "strand", "pos", "qwidth", "mapq", "cigar", "seq");
      whh <- get_loading_range(prm$roi, fbam);
      
      # Prepare reference sequence
      vref <- readFasta(c(prm$ref));
      nref <- sub(' .+$', '', as.character(vref@id));
      vref <- vref@sread;
      names(vref) <- nref;
      
      # Prepare region annotation 
      vann <- get_anno_range(prm$ann, fbam);
      
      #################################################
      valn <- load_align_table(fbam, flg, wht, whh); ##
      #################################################
      
      valn$rname <- as.character(valn$rname);
      valn <- valn[valn$rname %in% names(vref) & valn$rname %in% names(vann), , drop=FALSE];
      
      ##################################################################################
      if (nrow(valn) == 0) vsmm <- NULL else { 
        vsmm <- lapply(1:nrow(valn), function(i) { # print(i);
          bas <- BreakdownAlnByBase(valn, i, vref[[valn$rname[i]]]);
          smm <- BreakdownAlnByRegion(bas, vann[[valn$rname[[i]]]]);
          cbind(seq_name=valn$rname[i], read_id=valn$qname[i], smm); 
        });
        names(vsmm) <- rownames(valn);
      }
      
      vsmm;
    }); 
  };
  ######################################################  
  
  #########################################################################################
  saveRDS(list(genome=gbrk, vector=vbrk), paste0(yml$output$prefix, '_breakdown_all.rds'));
  #########################################################################################  
  
  ## Breakdown of all alignments to genomes in one table
  gbrk1 <- do.call('rbind', lapply(gbrk, function(b) do.call('rbind', b)));
  gbrk1 <- data.frame(ref_name=rep(names(gbrk), sapply(gbrk, function(b) sum(sapply(b, nrow)))), gbrk1);
  
  ## Breakdown of all alignments to vectors in one table
  vbrk1 <- do.call('rbind', lapply(vbrk, function(b) if (is.null(b)) NULL else do.call('rbind', b)));
  vbrk1 <- data.frame(ref_name=rep(names(vbrk), sapply(vbrk, function(b) if (is.null(b)) 0 else sum(sapply(b, nrow)))), vbrk1);
  
  ## Full breakdown table
  brk.tbl <- rbind(gbrk1, vbrk1);
  brk.tbl <- cbind(ref_type=rep(names(yml$input), c(nrow(gbrk1), nrow(vbrk1))), brk.tbl); 
  #################################################
  
  ###################################
  ## Summarize alignment breakdown ##
  ###################################
  
  #######################################################################################################################
  ## Get maximum read length in all bam files
  read.len <- lapply(c(gyml, vyml), function(y) {
    b <- y$bam;
    if (!file.exists(b)) NULL else {
      w <- get_loading_range(y$roi, b);
      a <- load_align_table(b, scanBamFlag(isUnmappedQuery = FALSE), c('qname', 'qwidth'), w);
      if (nrow(a) == 0) NULL else {
        q <- a$qwidth;
        names(q) <- a$qname;   
        q;
      }
    }
  });
  read.len <- sapply(split(unlist(read.len, use.names = FALSE), unlist(lapply(read.len, names))), max);
  
  #######################################################################################################################
  ## Get unaligned regions of each read in any of the bam files
  aligned <- lapply(c(gyml, vyml), function(y) { # print(y[[1]]);
    b <- y$bam;
    if (!file.exists(b)) NULL else {
      w <- get_loading_range(y$roi, b);
      a <- load_align_table(b, scanBamFlag(isUnmappedQuery = FALSE), c('qname', 'qwidth', 'cigar'), w);
      if (nrow(a) == 0) NULL else {
        u <- cigarRangesAlongQuerySpace(a$cigar, ops = c('M'));
        s <- rep(a$qname, elementNROWS(u));
        q <- a$qwidth;
        names(q) <- a$qname;
        q <- q[!duplicated(names(q))];
        if (length(s) == 0) NULL else {
          g <- GRanges(s, Reduce('c', u), seqlengths = q);
          g <- as(coverage(g, width = q), 'GRanges');
          g <- g[g$score>0];
          g <- as(coverage(g, width = q), 'GRanges');
          g <- g[g$score>0];
        }
      }
    }
  }); 
  aligned <- suppressWarnings(Reduce('c', aligned));
  unaligned <- as(coverage(aligned), 'GRanges');
  unaligned <- unaligned[unaligned$score==0];
  unaligned@elementMetadata <- DataFrame(width=width(unaligned));
  #######################################################################################################################
  
  #######################################################################################################################
  ## Summarize by reads
  read.id <- unique(brk.tbl$read_id);
  by.read <- lapply(read.id, function(rid) { # print(rid);
    brk <- brk.tbl[brk.tbl$read_id==rid, , drop=FALSE];
    brk <- brk[!is.na(brk$ref_start), , drop=FALSE];

    ## Alignment range on reference and read
    rng0 <- cbind(brk$ref_start, brk$ref_end);
    rng1 <- cbind(brk$read_start, brk$read_end);
    rng0[is.na(rng0)] <- 0;
    rng1[is.na(rng1)] <- 0;
    rng0 <- IRanges(rng0[, 1], rng0[, 2]);
    rng1 <- IRanges(rng1[, 1], rng1[, 2]);
    
    ## Split by references
    ind0 <- list(which(brk$ref_type %in% names(yml$input)));
    ind1 <- lapply(names(yml$input), function(nm) which(brk$ref_type %in% nm));
    ind2 <- lapply(unlist(lapply(yml$input, names)), function(nm) which(brk$ref_name %in% nm));
    inds <- c(ind0, ind1, ind2);
    names(inds) <- c('total', names(yml$input), unlist(lapply(yml$input, names)));
    
    ## Alignment length by references
    len0 <- sapply(inds, function(i) {
      if (length(i) == 0) c(0, 0) else {
        cov0 <- coverage(rng0[i]);
        cov1 <- coverage(rng1[i]);
        c(sum(runLength(cov0)[runValue(cov0)>0]), sum(runLength(cov1)[runValue(cov1)>0]));
      }
    }); 
    len1 <- len0[1, ];
    len2 <- len0[2, ];
    names(len1) <- paste0(colnames(len0), '_ref');
    names(len2) <- paste0(colnames(len0), '_read');
    
    ## Unaligned 
    una <- unaligned[seqnames(unaligned)==rid];
    # una <- una[width(una)>=20];
    if (length(una) == 0) {
      una <- NULL;
      ulen <- 0;
    } else {
      una <- una@ranges;
      ucov <- coverage(una);
      ulen <- sum(runLength(ucov)[runValue(ucov)>0]);
    }

    list(length=c(len1, len2, unaligned=ulen), aligned=brk, unaligned=una);
  });
  names(by.read) <- read.id;
  saveRDS(by.read, paste0(yml$output$prefix, '_breakdown_by_read.rds'));
  
  len.by.read <- do.call('rbind', lapply(by.read, function(r) r[[1]]));
  len.by.read <- cbind(read_length=read.len[rownames(len.by.read)], len.by.read);
  saveRDS(len.by.read, paste0(yml$output$prefix, '_summary_by_read.rds'));
  #######################################################################################################################
  
  #######################################################################################################################
  ## Summarize by regions
  reg.ann <- lapply(yml$input, function(ref) {
    reg <- lapply(ref, function(prm) {
      a <- get_anno_range(prm$ann, prm$bam, fill.gap = FALSE);
      GRanges(rep(names(a), sapply(a, length)), Reduce('c', a));
    }); 
    reg[!sapply(reg, is.null)];
  }); 
  reg.ann <- reg.ann[sapply(reg.ann, length)>0];
  by.region <- lapply(names(reg.ann), function(nm1) { print(nm1); 
    by.reg <- lapply(names(reg.ann[[nm1]]), function(nm2) { print(nm2); 
      reg <- reg.ann[[nm1]][[nm2]];
      snm <- as.vector(seqnames(reg));
      smm <- lapply(1:length(reg), function(i) {
        brk <- brk.tbl[brk.tbl$ref_type==nm1 & brk.tbl$ref_name==nm2 & brk.tbl$seq_name==snm[i] & brk.tbl$region_name==names(reg)[i], , drop=FALSE];
        brk <- brk[!is.na(brk$ref_start) & !is.na(brk$ref_end), , drop=FALSE];
    
        mtx <- matrix(0, nr=length(read.id), nc=10);
        rng <- GRanges(brk$read_id, IRanges(brk$ref_start, brk$ref_end), seqlengths = read.len[unique(brk$read_id)]);
      })
      
    })
  })
}

## Break down alignments in a bam file
# fbam <- "/ebs/home/zhangzhe/Project/2023-12_ONT_22-161_HDRvsNHEJ/C617_22-161_d91/22-161_d91_donor_sorted.bam";
# fbed <- "/ebs/home/zhangzhe/Project/2023-12_ONT_22-161_HDRvsNHEJ/C617_22-161_d91/p6575.bed";
# fann <- "/ebs/home/zhangzhe/Project/2023-12_ONT_22-161_HDRvsNHEJ/C617_22-161_d91/region_p6575.bed";
# ref <- readFasta('p6575.fasta')@sread;
# names(ref) <- 'p6575';
# rid <- character(); 
# rid <- unique(aln$qname)[1:12];
# param <- ScanBamParam(flag = scanBamFlag(isUnmappedQuery = FALSE));
BreakdownAlnFromBam <- function(fbam, fbed=NA, fann=NA, ref, rid=character(), param=NA) {
  # fbam          Name and path of a bam file indexed by alignment positions
  # fbed          Name and path of a bed file that specifies the regions on reference sequences to filter the alignments
  #               Alternative, a data.frame with at least 3 columns in order: sequence name, start position, and end position
  #               Alternative, a GRanges object specifies sequence name, start position, and end position of the regions
  # fann          Name and path of a bed file that specifies annotated regions in reference sequence if given; first 4 columns are required; summarize full alignments themselves if NA
  # ref           A DNAStringSet or BSgenome object of named reference sequences; sequence names must match the names in the bam and bed files
  # rid           Vector of read IDs that specifies a subset of reads to select
  # param         A ScanBamParam object to specify extra parameters to filter the alignments
  
  require(Biostrings);
  require(Rsamtools);
  
  ## Prepare loading parameters
  if (identical(NA, param)) param <- ScanBamParam(flag = scanBamFlag(isUnmappedQuery = FALSE));
  param@what <- scanBamWhat()[c(1:8, 12)];
  if (length(param@which) == 0) {
    if (file.exists(fbed)) {
      bed <- strsplit(readLines(fbed), '\t');
      seq <- sapply(bed, function(x) x[1]);
      stt <- as.integer(sapply(bed, function(x) x[2]));
      end <- as.integer(sapply(bed, function(x) x[3]));
      whh <- which(!is.na(stt) & !is.na(end));
      if (length(whh) > 0) param@which <- as(GRanges(seq[whh], IRanges(stt[whh], end[whh])), 'IRangesList');
    } else if (class(fbed) == 'data.frame') {
      param@which <- as(GRanges(fbed[, 1], IRanges(fbed[, 2], fbed[, 3])), 'IRangesList');
    } else if (class(fbed) == 'GRanges') param@which <- as(fbed, 'IRangesList');
  };
  
  ##################################################################################
  aln <- data.frame(scanBam(fbam, param = param)[[1]], stringsAsFactors = FALSE);
  ##################################################################################
  
  ## Filter by read ID if they are specified
  rid <- rid[rid %in% aln$qname];
  if (length(rid) > 0) aln <- aln[aln$qname %in% rid, , drop=FALSE];
  
  # Prepare subregion annotation if file is provided
  if (file.exists(fann)) {
    bed <- strsplit(readLines(fann), '\t');
    rnm <- sapply(bed, function(x) x[1]);
    stt <- as.integer(sapply(bed, function(x) x[2]));
    end <- as.integer(sapply(bed, function(x) x[3]));
    nms <- sapply(bed, function(x) x[4]);
    ann <- data.frame(rname=rnm, region=nms, start=stt, end=end, stringsAsFactors = FALSE);
  } else ann <- data.frame(rname=character(), region=character(), start=integer(), end=integer(), stringsAsFactors = FALSE);
  # Split annotated regions by names of reference sequences, such as choromsomes and vectors. 
  unq <- unique(as.vector(aln$rname));
  reg <- lapply(unq, function(nm) {
    r <- ann[ann$rname==nm & !is.na(ann$region) & !is.na(ann$start) & !is.na(ann$end), , drop=FALSE];
    if (nrow(r) == 0) NA else {
      rng <- IRanges(r$start, r$end);
      names(rng) <- r$region;
      rng;
    }
  });
  names(reg) <- unq;
  
  ##################################################################################
  if (nrow(aln) == 0) smm <- NULL else {
    smm <- lapply(1:nrow(aln), function(i) {
      bas <- BreakdownAlnByBase(aln, i, ref[[aln$rname[i]]]);
      smm <- BreakdownAlnByRegion(bas, reg[[aln$rname[[i]]]]);
      cbind(ref=aln$rname[i], read=aln$qname[i], smm); 
    });
    names(smm) <- 1:nrow(aln); 
  }

  smm; 
}

## Break down an alignment base by base
BreakdownAlnByBase <- function(aln, ind, ref) {
  # aln   BAM file loaded as a data.frame, with required fields in SAM specifications (https://samtools.github.io/hts-specs/SAMv1.pdf, section 1.4) 
          ## QNAME, FLAG, RNAME, STRAND, POS, MAPQ, CIGAR, SEQ ##
  # ind   Row index of the alignment in the data.frame
  # ref   A DNAString object of reference sequence
  
  require(Biostrings);
  require(GenomicAlignments);
  
  colnames(aln) <- tolower(colnames(aln));
  
  ind <- ind[1];
  
  if (is.na(aln$cigar[ind])) NULL else { # Return NULL if the index is an unalignment row. 
    # Retrieve base by base pairwise alignment between reference and read 
    rng <- cigarRangesAlongPairwiseSpace(aln$cigar[ind], with.ops = TRUE)[[1]];
    rle <- rep(names(rng), width(rng));
    
    # Retrieve base by base pairwise alignment along reference
    rng1 <- cigarRangesAlongReferenceSpace(aln$cigar[ind], pos=aln$pos[ind], ops='M')[[1]];
    fst1 <- min(start(rng1)); # first alignment position on reference
    lst1 <- max(end(rng1)); # last alignment position on reference
    
    # Retrieve base by base pairwise alignment along read
    rng2 <- cigarRangesAlongQuerySpace(aln$cigar[ind], ops='M')[[1]];
    fst2 <- min(start(rng2));  # first alignment position on read
    lst2 <- max(end(rng2)); # last alignment position on read
    
    # Create an alignment table by positions
    pos1 <- pos2 <- rep(NA, length(rle));
    pos1[rle!='I'] <- fst1:lst1;
    pos2[rle!='D'] <- fst2:lst2;
    pos <- cbind(pos_ref=pos1, pos_read=pos2);
    # pos$op <- rle;
    
    # Retrieve base in the reference at specific position
    bas1 <- rep('-', nrow(pos)); # base at the specific position in the read
    ref1 <- subseq(ref, fst1, lst1);
    bas1[!is.na(pos[, 1])] <- strsplit(as.character(subseq(ref, fst1, lst1)), '')[[1]];
    
    # Retrieve base in the read at specific position
    bas2 <- rep('-', nrow(pos)); # base at the specific position in the read
    bas2[!is.na(pos[, 2])] <- strsplit(substr(aln$seq[ind], fst2, lst2), '')[[1]];
    
    tbl <- data.frame(pos_ref=pos1, pos_read=pos2, base_ref=bas1, base_read=bas2, op=as.vector(rle), stringsAsFactors = FALSE);
    
    # Reverse position in read if the alignment is minus
    str <- as.vector(aln$strand[ind]);
    if(str == '-') {
      tbl$pos_read <- nchar(aln$seq[ind]) + 1 - tbl$pos_read;
      tbl <- tbl[nrow(tbl):1, , drop=FALSE];
    } 
    
    tbl$match  <- as.integer(tbl$base_ref==tbl$base_read);
    tbl$strand <- c('-'=-1, '+'=1, '*'=0)[str];
    tbl$flag   <- aln$flag[ind];
    tbl$mapq   <- aln$mapq[ind];
    tbl$read_length <- nchar(aln$seq[ind]);
    
    rownames(tbl) <- paste0(ind, '_', 1:nrow(tbl));
    
    ## The output is a data.frame with the following columns: 
    ## pos_ref:   base position in reference sequence
    ## pos_read:  base position in original read (after hardclipping); reversed alignment position if aligned to minus strand of ref
    ## base_ref:  base in the referece sequence
    ## base_read: base in the read
    ## op:        CIGAR operation in the alignment table
    ## match:     Whether the base_ref and base_read are the same (0 if not the same)
    ## strand:    Whether the read is aligned to the plus or minus strand of the reference sequence (-1 if aligned to minus strand)
    ## flag:      Alignment flag according to SAM specification
    ## mapq:      Mapping quality in the alignment table
    ## read_length: Full read length (after hardclipping);
    tbl;
  }
}

####################################################################################################
## Break down alignment by regions; using output from the BreakdownAlnByBase()
BreakdownAlnByRegion <- function(bas, reg=NA) {
  # bas   output of BreakdownAlnByBase function
  # reg   Named IRanges object that specifies the annotated subregions in the reference sequence; summarize the alignment itself if NA
  
  if (is.null(bas)) NULL else if (nrow(bas) == 0) NULL else {
    if (identical(NA, reg) | length(reg)==0) {
      reg <- range(bas$pos_ref, na.rm=TRUE);
      reg <- IRanges(reg[1], reg[2]);
      names(reg) <- "aligned";
    }
    
    smm <- data.frame(region_name=names(reg), region_start=start(reg), region_end=end(reg), region_len=width(reg), stringsAsFactors = FALSE);
    smm$align_strand <- bas$strand[1];
    smm$align_flag <- bas$flag[1];
    smm$align_mapq <- bas$mapq[1];
    smm$read_end <- smm$read_start <- smm$ref_end <- smm$ref_start <- NA;
    smm$max_insertion <- smm$max_deletion <- smm$n_insertion <- smm$n_deletion <- smm$n_mismatch <- smm$n_match <- smm$align_len <- 0;
    smm$read_seq <- smm$ref_seq <- smm$cigar <- "";
    
    for (i in 1:length(reg)) { # print(i); # For every annotated region
      fst <- start(reg)[i]; 
      lst <- end(reg)[i];
      whh <- which(!is.na(bas$pos_ref) & bas$pos_ref>=fst & bas$pos_ref<=lst); # row index of the bases overlapping the region
      if (length(whh) > 0) { # There are bases overlapping the region
        seg <- bas[min(whh):max(whh), , drop=FALSE]; # Segment of the alignment overlapping the annotated region
        
        # Reference sequence overlapping the region
        ref <- seg[, c('pos_ref', 'base_ref'), drop=FALSE];
        ref <- ref[ref$base_ref!='-', , drop=FALSE];
        if (nrow(ref) == 0) ref <- "" else {
          ref <- ref[order(ref$pos_ref), , drop=FALSE];
          smm$ref_start[i] <- min(ref$pos_ref, na.rm=TRUE);
          smm$ref_end[i] <- max(ref$pos_ref, na.rm=TRUE);
          smm$align_len[i] <- smm$ref_end[i] - smm$ref_start[i] + 1;
          smm$ref_seq[i] <- paste(ref$base_ref, collapse='');
        }
        
        # Read sequence overlapping the region
        seq <- seg[, c('pos_read', 'base_read'), drop=FALSE];
        seq <- seq[seq$base_read!='-', , drop=FALSE];
        if (nrow(seq) > 0) {
          seq <- seq[order(seq$pos_read), , drop=FALSE];
          if (bas$strand[1] == -1) seq <- seq[nrow(seq):1, , drop=FALSE];
          smm$read_start[i] <- min(seq$pos_read, na.rm=TRUE);
          smm$read_end[i] <- max(seq$pos_read, na.rm=TRUE);
          smm$read_seq <- paste(seq$base_read, collapse='');
        };
        
        # Count base matching by categories
        bas1 <- seg$base_ref;
        bas2 <- seg$base_read;
        smm$n_match[i]     <- length(bas1[bas1==bas2]);
        smm$n_deletion[i]  <- length(bas1[bas1!='-' & bas2=='-']);
        smm$n_insertion[i] <- length(bas1[bas1=='-' & bas2!='-']);
        smm$n_mismatch[i]  <- length(bas1[bas1!='-' & bas2!='-' & bas1!=bas2]);
        
        # Max length of deletion/insertion
        rle1 <- Rle(bas1);
        rle2 <- Rle(bas2);
        smm$max_deletion[i]  <- max(c(0, runLength(rle1)[runValue(rle1)=='-']));
        smm$max_insertion[i] <- max(c(0, runLength(rle2)[runValue(rle2)=='-']));
        
        # Construct a CIGAR string for the region based on the alignment
        ops <- rep('M', nrow(seg));
        ops[bas1!='-' & bas2=='-'] <- 'D';
        ops[bas1=='-' & bas2!='-'] <- 'I';
        ops[bas1!='-' & bas2!='-' & bas1!=bas2] <- 'X';
        ops <- Rle(ops);
        ops <- paste0(runLength(ops), runValue(ops));
        smm$cigar[i] <- paste(ops, collapse = '');
      };
    };
    
    smm; 
  };
}



